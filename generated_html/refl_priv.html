<!DOCTYPE html><html lang ="en"><head><meta name="viewport" content="width=device-width, initial-scale=1"><title>Rust, reflection and access rules</title><link rel="stylesheet" href="default.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css" media="none" onload="if(media!='all')media='all'">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script async src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
<script>window.addEventListener('load', () => {
const start = Date.now();
hljs.addPlugin(new CopyButtonPlugin());
function cil() {
  const regex = hljs.regex;
     const KEYWORDS = ["locals","method","public","static","private","hidebysig","assembly","class","extends","field","entrypoint","line"];
   var types = ["int8","int16","int32","int64","nint","uint8","uint16","uint32","uint64","nuint","bool","char","float32","float64","void","uint","int","valuetype","native"];
   var short_types = ["i1","i2","i4","i8","s","u1","u2","u4","u8"];
   var ops = ["conv","ldloc","ldc","add","stloc","ret","call","ldarg","ldarga","sizeof","mul","ldobj","div","blt","br",".rs",".s","calli"];

   var keywords = {
    keyword: KEYWORDS,
    $pattern:/(\w+)/,
    relevance:10,
    literal: types.concat(ops).concat(short_types),
  }
  
  var INLINE_COMMENT = hljs.COMMENT('//', '[^\\\\]$');
  return {
    unicodeRegex: true,
    aliases: ['cil','common_intermediate_language'],
    keywords: keywords,
    contains: [
      INLINE_COMMENT, // single-line comments
      hljs.C_BLOCK_COMMENT_MODE, // comment blocks
    ]
  };
}
function mir() {
  const regex = hljs.regex;
     const KEYWORDS = ["switchInt","unreachable","return","unwind","continue"];

   var vars = ["bb0","bb1","bb2","bb3","bb4","_0","_1","_2"];

   var keywords = {
    keyword: KEYWORDS,
    $pattern:/(\w+)/,
    relevance:10,
    literal: vars,
  }
  
  var INLINE_COMMENT = hljs.COMMENT('//', '[^\\\\]$');
  return {
    unicodeRegex: true,
    aliases: ['mir'],
    keywords: keywords,
    contains: [
      INLINE_COMMENT, // single-line comments
      hljs.C_BLOCK_COMMENT_MODE, // comment blocks
    ]
  };
}

hljs.registerLanguage('cil',cil);
hljs.registerLanguage('mir',mir);
hljs.highlightAll();

const end = Date.now();
console.log(`Highlight time: ${end - start} ms`);
});</script></head><body><div class = "nav_container"><nav class="topnav">
            <b><a class="active" href="./home.html">Home</a></b>
            <a href="https://www.github.com/FractalFir"><img src = "../images/github-mark-white.svg" class = "github_link" width = "25" height = "25" alt = "Link to my github account."></a>
            <a href="https://www.reddit.com/user/FractalFir"><img src = "../images/Reddit_Mark_OnWhite.svg" class = "reddit_link" width = "27.5" height = "27.5" alt = "Link to my reddit account."></a>
            <a href="https://www.linkedin.com/in/micha%C5%82-kostrubiec-85a037269/"><img src = "../images/LI-In-Bug.png" class = "linked_id_link" height = "27.5" alt = "Link to my linkedin account."></a>
            <a href="https://fractalfir.github.io/generated_html/rss.xml"><img src = "https://upload.wikimedia.org/wikipedia/en/4/43/Feed-icon.svg" class = "rss_link" height = "27.5" alt = "Link to my rss feed."></a>
        </nav></div><div class = "article_header"><h1 class="title">Rust, reflection and access rules</h1><br><small><div class = "article_metadata">Published on 28 Dec 2024<br><i>9 - 15 minute read</i></div></small></div><div class="article"><div class = "paragraph"><p>Reflection is something a lot of people wish the Rust language had. Sadly, it does not look like it is going to be added any time soon.</p>

<p>Still, silly things like “this feature does not exist yet” can’t stop us from talking about how it could or even must work. (Un)surprisingly, reflection interacts with the safety features of Rust in a somewhat counterintuitive way, which forces any proposed API to adhere to a set of rules, mainly around accessing fields of Rust types.</p>

<p>This article will discuss some of those rules, explain why they exist, and present a few alternative solutions. I will mainly focus on field visibility(public vs private), and reflection failures.</p>

<h1 id='field_access_rules'>Field access rules</h1>

<p>In a lot of languages, reflection is able to access all the fields of an object, no matter if they are private or not. Reflection just seems to be a bit special, and able to bend the rules here and there.</p>

<p>There are, of course, some restrictions to this, but, in general, the rules around reflection tend to be less strict.</p>

<p>Coming from a high-level language with reflection, it seems reasonable to assume that this is a natural part of reflection. You can set the value of a private field in C#:</p>

<pre><code class="language-csharp">class Test {
  private float _secret;
}
void SetSecret(Test test, float val) {
  typeof (Test).GetField(&quot;_secret&quot;, BindingFlags.NonPublic | BindingFlags.Instance).SetValue(test, val);
}</code></pre>

<p>In java:</p>

<pre><code class="language-java">class Test {
	private float _secret;
}
class Spy {
	void SetSecret(Test test, float val) {
    	Field field = getField(test.getClass(), “_secret”);
    	field.setAccessible(true);
    	field.set(object, val);
	}
}</code></pre>

<p>This is even easier in other languages, like python or lua; There, the notion of privacy is more of a courtesy than a rule.</p>

<pre><code class="language-pyhton">setattr(test, “__secret”,val);</code></pre>

<pre><code class="language-lua">test[“secret”] = val;</code></pre>

<p>Doing things this way is often seen as an anti-pattern, since it breaks encapsulation. Nevertheless, it is useful in certain scenarios; for example, when serialising and deserializing data. After all, requiring all serializable / deserializable fields to be public would probably bring more trouble than it is worth.</p>

<p>You may ask: So what? Yes, in a lot of modern languages, reflection is able to access private fields, but what has it got to do with Rust?</p>

<p>Well, things can’t work this way in Rust, no matter what reflection API ends up being implemented. Let me show you why.</p>

<h1 id='proof_by_contradiction'>Proof by contradiction</h1>

<p>Shockingly, you don’t need all that much to show the problem at hand. I would say that it is kind of obvious when you think about it, and a decent chunk of Rust developers can already see the writing on the wall.</p>

<p>Let us suppose we have some way of accessing all fields using reflection, and we use that hypothetical API to write a function like this:</p>

<pre><code class="language-rust ">/// Gets a mutable reference to the first field of a struct using reflection
fn get_first_field_mut&lt;T,F&gt;(t:&amp;mut T)-&gt;&amp;mut F{
	// Implemented using reflection 
}</code></pre>

<p>At a first glance, it does not seem all that scarry. It doesn’t do much, besides just getting a mutable reference to a (potentially) private field.</p>

<p>In other languages, accessing private fields is considered a necessary evil. Sure, if you get too... creative with it, your coworkers might want to make you past tense. Still, as long as you have a <em>very good reason</em> to use reflection like this, and use it sparingly, everything is going to be fine.</p>

<p>In Rust, this is something that simply can’t be done - allowing reflection to access private fields is <em>fundamentally unsound</em>.</p>

<p>How? Let me show you.</p>

<p>Using this simple, and seemingly innocent function, we write something like this:</p>

<pre><code class="language-rust">let boxed = Box::new(1_i32);
let unique = get_first_field_mut(&amp;mut boxed);
let non_null = get_first_field_mut(unique);
let raw_ptr:&amp;mut *const i32 = get_first_field_mut(non_null);
*raw_ptr = 0xDEAD_BEEF_usize as *const i32;</code></pre>

<p>While what is happening here may seem complex, it is pretty straightforward. We just traverse the types making up a <code>Box&lt;i32&gt;</code> till we find its inner pointer, and then corrupt it to cause UB once the box is dropped or accessed.</p>

<p>With this, I think you can clearly see why reflection in Rust must respect the field access rules.</p>

<p>In other languages, breaking those rules is going to make your program hard to read. In Rust, those rules are strictly necessary for enforcing safety. Breaking them kind of breaks the whole language, which is less than ideal.</p>

<p>So, reflection in Rust must either respect access rules(aka “field privacy”) or be <em>unsafe</em>.</p>

<p>Immediately, you may have a few questions.</p>

<ol type="1">
<li>This problem seems to be caused by us creating a mutable reference to a private field. Do immutable references have similar problems?</li>

<li>This issue is caused by a pointer. Would forbidding accessing pointers in reflection help?</li>

<li>Is this that big of an issue? Nobody is going to write code like that anyway?</li>

<li>Why does reflection even need to access private fields? What would be the limitations of reflection without access to private fields?</li>
</ol>

<p>All of them are important, so let's start with the first few.</p>

<p>At first, it may seem like we need mutable access to cause any trouble. After all, if we can’t change the underlying data, we can’t really cause any harm, can we? So, you might think that kind of restriction on reflection should be enough.</p>

<p><em>Well</em>, we can still do quite a bit of harm with an “immutable” reference. While <em>most</em> rust types can’t be changed without obtaining a mutable reference, some of them can. So, allowing any sort of unintended access to private fields is a recipe for disaster.</p>

<p>Consider the reference count of an <code>Arc</code>. The counter is an <code>AtomicUSize</code> - a type which can be changed, without the need for a mutable reference. If we could, for example, set its counter to <code>1</code>, when it ought to be higher, we could cause an use-after-free bug.</p>

<pre><code class="language-rust">let a = Arc::new(7);
let b = a.clone();
let count = get_arc_count_via_reflection(&amp;a);
count.store(1, Ordering::Relaxed);
// Frees the underlying arc - b is now dangling!
drop(a);</code></pre>

<p>This example also shows the second issue: it is not just pointers we need to worry about.</p>

<p>Changing pretty much any private data can cause issues. We could, for example, corrupt an integer, representing a handle to an object created by a C library. This could, in turn, lead to soundness issues.</p>

<pre><code class="language-rust">// A OpenGL Vertex Buffer Object is just a uint on the C side
let mut vbo = /* get VBO from Open-Gl */;
let handle = get_first_field_mut(&amp;mut vbo);
handle = 0xDEAD_BEEF_u32; // We change the OpenGL handle - bad things could happen now
// Oops! We used a corrupted handle...
vbo.bind();</code></pre>

<p>This hopefully shows that reflection with access to private fields could lead to issues. You might be tempted to ask: are those issues realistic?</p>

<p>The simplest, but a bit boring answer to this question is that this does not matter. Even if something is “unlikely” to cause UB, it still must be unsafe in Rust. So, if accessing private fields via reflection could cause UB, then it is by definition, unsafe.</p>

<p>Let me ask you a simple question: what should happen when somebody uses reflection to try to serialize(eg. save to disk) an OpenGL buffer? If we don’t restrict reflection, then the serialization framework may just save the handle as a plain integer.</p>

<p>Then, when we deserialize it, it is going to be invalid, and can cause serious trouble.</p>

<p>Rust is a language focused on security, and requiring people to know what can and can’t be safely serialized just does not mesh well with that.</p>

<h2 id='unsafe_fields'>Unsafe fields</h2>

<p>By this point, you probably get the general gist of things. Reflection in Rust simply can't safely access private fields. I think a lot of people also think that allowing reflection to access private fields is a bad idea in general. So, not much is lost here.</p>

<p>Still, saying that something is “not possible and also a bad idea” feels a bit anticlimactic. Surely, there must be some way to eat our cake and have it too. Enabling reflection to access private fields is arguably useful: a lot of languages use reflection to implement serialization.</p>

<p>Ideally, we would not want to force all serializable types to only have public fields. That is probably going to cause a lot more trouble than it is worth.</p>

<p>You might think: Ok, so we can’t allow reflection to access all private fields, since some of them may be unsafe to access. We still may want it to access some fields that we would like to stay private otherwise.</p>

<p>Maybe we could implement a visibility marker that allows for reflective access to such fields?  Something like:</p>

<pre><code>struct MostlyPrivate{
 	/// Normally private, but accessible via reflection
	pub(reflect) id:u32,
}</code></pre>

<p>This, at least to me, looks reasonable. We explicitly opt in to reflection, clearly marking which fields it can and can't change. We still get some of the benefits of making things private. Such fields are not accessible from &quot;normal&quot;(human-written) code, so it is unlikely somebody will access them by accident.</p>

<p>Reflection is not easy, and if somebody uses it to access such a field, we should just let them do so. Clearly, they have a rough idea about what they are getting themselves into.</p>

<p>This solution is not perfect, but it forces us to acknowledge the potential issues and work around them.</p>

<p>Still, one might argue that the opt-in nature of this feature would lead to a lot of people forgetting about it. It would require some change to the thinking of crate authors, who would have to explicitly add reflection support for their types.</p>

<p>Alternatively, we could consider poaching a few ideas from the unsafe fields feature.</p>

<pre><code class="language-rust">struct FloatAndEven{
	/// Safety: must be even!
	// Invisible to reflection, since it is unsafe
	unsafe even:i32,
	// Accessible via reflection, since it is not unsafe
	float:f32,
}</code></pre>

<p>If we assume any field which is not unsafe can be safely reflected on, then maybe things will work out? It is hard to say if this would be enough, and I am not convinced mixing reflection access and field safety is a good idea. Still, I feel like this solution is something that ought to be mentioned for the sake of completeness.</p>

<h1 id='domino_effect:_how_those_restrictions_affect_reflection'>Domino effect: how those restrictions affect reflection</h1>

<p>At this point, you probably see why reflection in Rust must respect field access rules. I think most people would agree that allowing reflection to break them is a bad idea in general. So, I don’t think anybody is going to be too mad at this “restriction”.</p>

<p>All proposals I have seen so far do things this way anyway, so this is not a big discovery. Still, I like to explain why something is a certain way before I explain the consequences of that behaviour. Now that this is out of the way, we can start talking about something far more interesting: the knock-on effects.</p>

<p>Think for a second about what should happen when something goes wrong during reflection. You can’t safely deserialize a type like this:</p>

<pre><code class="language-rust">struct NotOk{
	// Private field reflection can’t access 
	private:u32,
}</code></pre>

<p>Reflection can’t access some of its fields, so it can’t be used for deserialization. This leads me to ask a simple question: what should happen then? The obvious answer is that this should result in a compiler error, but… it is not as simple as that.</p>

<h2 id='why_reflection_needs_custom_bounds'>Why reflection needs custom bounds</h2>

<p>To give an example, let us say that we create a serialization function like this:</p>

<pre><code class="language-rust">pub fn serialize&lt;T: /* What should go there???*/&gt;(t:&amp;T, out: &amp;mut impl Write)-&gt;SerializationResult{
	/* Implemented using reflection*/
}</code></pre>

<p>How should we express the bounds of reflection-based serialization? To serialize a type using reflection, we need it to fulfill a set of non-trivial criteria.</p>

<p>All of its fields need to be accessible via reflection Each and every single field type must also be serializable, that is either: A primitive type, e.g. <code>a:i32</code> A type with an explicit serialization implementation, eg. <code>b:Box&lt;i32&gt;</code> A type which also fulfils our criteria <code>c:SomeOtherSerializableType</code> Thus, a simple question arises: how are we supposed to express those complex bounds?</p>

<p>One idea might be to… just not add any such bounds at all? If our reflection-based serialization framework errors out with a descriptive message, then isn’t this bound kind of redundant?</p>

<pre><code>error[E1234]: reflection error
  --&gt; my_type.rs:32:64
   |
32 | pub(crate) not_serializable:*mut i32,
   | -^^^^- This field cannot be accessed via reflection
   |  |
   |  type MyType can’t be serialized because of this field
   |
   = note: Error during compile-time reflection
note: this error was caused by a reflection-based function called here
  --&gt; test_serialization.rs:128:256
   |
128 | serialize(&amp;my_type, &amp;mut out_file).unwrap();
   |      ^^^^</code></pre>

<p>Sadly, no. Consider a much more complex example. Who is to say that the problematic function is called directly? The error could, for example, originate <strong>deep</strong> within a networking framework, which ensures a piece of data stays in sync across the network.</p>

<pre><code>my_crate::my_code 
network_framework::SharedData&lt;MyType&gt;::new
network_framework::SharedData&lt;MyType&gt;::sync
network_framework::SharedData&lt;MyType&gt;::send
reflection_serializer::serialize&lt;MyType&gt;</code></pre>

<p>Now, we have to go several layers deep to understand the root cause of the issue. How should that be displayed? If we had some support for expressing reflection bounds, each function in this mass of abstractions would have to transparently tell us about what can and can’t be serialized.</p>

<p>Also, who is to say that the problem is directly with the type we have created? Maybe we are using types from other crates, which in turn use other crates, and the problem is with the type all the way down?</p>

<p>Now, our reflection error backtrace will grow even larger and even more confusing. Since reflection can “fail”(eg. not have access to all the data it needs), we need to handle that in a sane way.  We don’t want to confuse people with deeply nested backtraces talking about types and functions from a whole bunch of crates, we want our reflection errors to be simple and concise. If we could do something like this:</p>

<pre><code class="language-rust">fn serialize&lt;T:SerializableViaReflection&gt;(t:&amp;T, out:&amp;mut impl Write) -&gt;SerializationResult{}</code></pre>

<p>Then, all the crates using such a reflection-based serialisation framework could also transparently express this requirement.</p>

<pre><code>// In network_framework
fn send&lt;T:reflection_serializer::SerializableViaReflection&gt;(t:T){}</code></pre>

<p>Thus, we need some way to express the exact requirements of reflection as some kind of bounds. We need more control over those bounds, to express all the complex requirements of reflection.</p>

<h2 id='how_can_we_express_such_complex_bounds?'>How can we express such complex bounds?</h2>

<p>Your gut feeling may be adding some simple-ish mechanism to check if a generic condition holds true for all fields.</p>

<p>However, this may not be nearly as simple as one might imagine.</p>

<p>A lot of people want to do a lot of different things with reflection. In each scenario, the requirements are a tiny bit different.</p>

<p>For example: let us say we have a function that sends some data between different devices. For optimization purposes, it only supports types which can be trivially copied between those devices: that is, they are <code>Copy</code> and their layout does not depend on the device in question: they are bitwise identical after they are sent. This is not something any combo of traits can currently express.</p>

<p>Furthermore, we may want to use reflection for interop. To give an example, my crate, <code>wrapped_mono</code>, currently uses unsafe marker traits to check if a type can be shared between C# code running within the .NET runtime and Rust. On the .NET side, I have access to APIs which can check the exact layout of a type. If I could do the same on the Rust side, I could ensure all the safety requirements in the crate code. All of my traits would then become safe, since I could prove that the types on both ends meet.</p>

<p>This kind of requirement can’t be expressed trivially. Furthermore, one might consider using reflection for automatically registering Rust types in an embedded scripting environment. Once again, the requirements here are not trivial expressible using the current trait system, which limits the usefulness of any potential reflection API in that use case.</p>

<p>If we want to implement something like that using reflection, we need some way of turning those vague requirements into generic bounds.<br /></p>

<p>One idea here might be to also use reflection to express those requirements.</p>

<p>We could try something like this:</p>

<pre><code class="language-rust">const fn is_serializable&lt;T&gt;()-&gt;bool{
	/* Do our complex checks using reflection*/
}
// Only valid if is_serializable&lt;T&gt;() returns true
fn serialize&lt;T&gt;(t:&amp;T, out:impl Write) where True&lt;{is_serializable::&lt;T&gt;()}&gt;</code></pre>

<p>In this scenario, we express the bound required for reflection… using reflection. This approach has the benefit of being very flexible. We are not limited by what kind of checks we could possibly perform, and we could ensure some very complex safety invariants at compile time, which is neat.</p>

<p>However, once again, this approach is not without its own drawbacks. Writing those bounds is not trivial, which would make using reflection in Rust... not easy by any stretch of imagination. Still, reflection is not easy in general, so one might argue that this does not matter as much here.</p>

<p>The bigger drawback is, in my opinion, the problem of self-referential types. Consider this one:</p>

<pre><code class="language-rust">struct IsThisThingSerializable{
	normal_field:u32,
	recursive:Option&lt;Box&lt;Self&gt;&gt;,
}</code></pre>

<p>Checking if this thing fulfils our complex reflection requirements is not trivial. This type can be serialized if all of its fields(including <code>recursive</code>) can be serialized. To determine if that field can be serialized, we need to check if... the original type in quiestion can be serialized.</p>

<p>A naive approach, written using recursion, would quickly get stuck in a loop.</p>

<p>Making this work reliably is not trivial. There could exist some kind of crate that makes this process easier, but I still feel like the complexity of reflection rears its ugly head here too.</p>

<p>Overall, it seems like this is, once again, something that makes implementing reflection in Rust all that more tricky.</p>

<h1 id='uncharted_seas'>Uncharted seas</h1>

<p>I feel a bit weird leaving this article without presenting a neat solution to the problems I presented. However, I think this is the most important thing to take away here: we kind of are in uncharted waters. Reflection has been implemented in other languages before, but I don’t believe it ever was implemented in a language as unique as Rust.</p>

<p>Rust’s focus on enforcing safety via its type system also forces reflection to be more strict, and perhaps a bit more cumbersome.</p>

<p>This whole article was mostly inspired by my numerous failed attempts at designing a decent reflection API for Rust. Time and time again, I feel like I kind of smashed into the same potential issues, despite using vastly different approaches.</p>

<p>Sometimes, I feel like attempting to add reflection to Rust is kind of like trying to cover a table with too small of a tablecloth: you always end up sacrificing something. Some of my ideas were very powerful, decently user-friendly, but ultimately unsafe. Others were safe, but required writing more boilerplate, and did not cover all the use cases I had in mind.</p>

<p>Maybe my inability to make a draft API that I am happy with is simply caused by my lack of experience, and those problems I presented have some obvious solutions I have not considered. Maybe those issues are exaggerated by my perfectionism, and inability to settle for a good-enough solution.</p>

<p>No matter the case, I still feel like they are at least interesting - and I probably should publish something about reflection, instead of letting the 11 draft articles I wrote rot in the cloud.</p>

<p>Who knows, maybe I will manage to get one of my design drafts into a presentable state in 2025 :).</p>
</div><script src="https://giscus.app/client.js"
        data-repo="FractalFir/FractalFir.github.io"
        data-repo-id="R_kgDOJ_iWYA"
        data-category="Announcements"
        data-category-id="DIC_kwDOJ_iWYM4CiwXV"
        data-mapping="pathname"
        data-strict="1"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async></script></div></body></html>