<!DOCTYPE html><html lang ="en"><head><meta name="viewport" content="width=device-width, initial-scale=0.5"><title>Rust here, Rust there, Rust everywhere!</title><link rel="stylesheet" href="default.css"></head><body><div class = "nav_container"><nav class="topnav">
            <b><a class="active" href="./home.html">Home</a></b>
            <a href="https://www.github.com/FractalFir"><img src = "../images/github-mark-white.svg" class = "github_link" width = "25" height = "25" alt = "Link to my github account."></a>
            <a href="https://www.reddit.com/user/FractalFir"><img src = "../images/Reddit_Mark_OnWhite.svg" class = "reddit_link" width = "27.5" height = "27.5" alt = "Link to my reddit account."></a>
            <a href="https://www.linkedin.com/in/micha%C5%82-kostrubiec-85a037269/"><img src = "../images/LI-In-Bug.png" class = "linked_id_link" height = "27.5" alt = "Link to my linkedin account."></a>
        </nav></div><div class="article"><h1 class="title">Rust here, Rust there, Rust everywhere!</h1><br><small><i>8 - 14 minute read</i></small><div class = "paragraph"><p>In this article, I describe my journey creating a <a href='https://github.com/FractalFir/rustc_codegen_clr'>barely functional rust backend enabling compilation for the .NET runtime</a> (Usually used to run C# and F#).</p>

<p>It is currently in the proof-of-concept stage, but I believe it still may be of some interest.</p>

<h1 id='why_would_one_compile_rust_for_.net_runtime?'>Why would one compile Rust for .NET runtime?</h1>

<p>At first, one might dismiss the idea right away. Why on earth would you compile Rust to the .NET runtime, if you can compile it to all architectures and OSes that .NET supports? Why even bother? There are a couple of reasons why.</p>

<ol type="1">
<li>It is pretty fun. There were moments where I was banging my head on the wall a little bit too much, almost waking my family at night. There were moments where I was reconsidering my life choices. But what is a good programming exercise without some pain?</li>

<li>It could make Rust/C# inter-op easier and <strong>FAR</strong> more powerful. Don't get me wrong, it is not all that hard right now. You do have to ship a compiled rust library for all the platforms you want to support, and use P/Invoke to interact with it, but that is all, in terms of complexity. But you are limited to C-ABI. You can't simply pass a managed C# array to Rust (without marshaling), or send managed references to C# objects to Rust. While this codegen does not allow that <em>yet</em>, it will in the future.</li>

<li>It enables using fast Rust libraries from C#. When (and if) the project matures, you could write a fast Rust library, and provide a C#/F# compatible version. To all outsiders, this would seem just like yet another C# library, just faster and with a bit of unsafe sprinkled about.</li>

<li>Much smaller memory footprint. Rust likes to guide you, to allocate all you can on the stack. This reduces memory usage, and produces nothing for GC to collect. This should make its life far easier.  Additionally, Rust will allocate only unmanaged heap memory. What does that mean? This is the memory GC knows not to worry about. It is the job of the program to free it. This fits nicely with Rust's memory management.</li>

<li>Ability to use Rust with .NET exclusive tools. Would it not be nice to just use Rust with all the numerous .NET tools? To potentially, far off in the future, write Unity games with Rust?</li>

<li>One executable to rule them all! You could compile your program once and have it run on all platforms supporting .NET. Windows, macOS, Linux? x86, ARM? 64 or 32 bit? All supported by one executable.</li>

<li>There already exists a version of C++ targeting .NET, so doing the same with Rust should be definitely possible! Besides, we don't want to be worse than the C++ people, do we ;)?</li>
</ol>

<p>So, now that I explained why I am doing this, let's get right into the inner workings!</p>

<h1 id='how_to_compile_anything_for_.net'>How to compile anything for .NET</h1>

<p>Compiling things for .NET may seem like a hard thing at first, but it is actually not. .NET uses the <code>Common Intermediate Language</code>, part of <code>Common Language Infrastructure</code>. It is an intermediate representation of C#/F# code. If you can emit fully valid CIL, it should be happily loaded by both the .NET runtime (Core CLR) and mono. There is a small, but important asterisk to this statement (<em>foreshadowing</em>), but more on this later.</p>

<p>How would one emit CIL? You could use the built-in C# APIs for code generation. That is very much what I will likely do in the future, but it has its own Rust-specific issues, and is generally just harder to do for this particular project. The great thing about CIL is that it has a human-readable form. What matters for our use-case is that it can be easily generated from the Rust side, and then turned into a compiled .NET assembly, using a tool called <code>ilasm</code>(Intermediate Language Assembler). This approach has 2 huge benefits: I can read the produced assembly and spot most of the mistakes. The C# decompiler can be used to get C# code equivalent to the assembly produced by my backend. It also helps verify that everything is going OK, because there is no way both <code>ilasm</code> and a C# decompiler would happily accept invalid IL that the .NET runtime would refuse to load, right?</p>

<h2 id='small_snippet_of_cil'>Small snippet of CIL</h2>

<p>C# code</p>

<pre><code class="language-C#">public static int Add2(int P_0)
{
    return P_0 + 2;
}</code></pre>

<p>CIL</p>

<pre><code class="language-cil">.method public static hidebysig int32 Add2(int32){
    ldarg.0
    ldc.i4 2
    add
    ret
}</code></pre>

<p>As you can see, CIL is stack based, and consists of a series of opcodes, manipulating this stack. Besides containing code, CIL also contains type info, but this is something I will go more in depth in another article.</p>

<h1 id='how_to_compile_rust_for_anything'>How to compile Rust for anything</h1>

<p>Rust is a very complicated language. Writing a compiler for it is hard, but we have more options for compiling Rust for any target we desire. Rust normally uses LLVM for code generation. But it does not have to: the rust compiler backend works as a plugin:</p>

<p>You can easily swap it out for another one, by simply pointing <code>rustc</code> to a relevant dynamic library using the <code>-Z codegen-backend=YOUR_CODEGEN_HERE.dll</code> flag. As long as it provides the relevant functions, <code>rustc</code> will pass you all the info needed for generating code for any crate. At this stage, a rust program is represented using the MIR(mid-level IR) format. It its relatively easy to handle, with a few quirks that can be ignored for our purposes. It seems very inspired by LLVM's IR, which makes sense, since it is usually converted to LLVM IR almost right away.</p>

<p>While MIR is not hard, getting to it is not a trivial task, since you first need to familiarize yourself with the relevant internal Rust APIs. I managed to get my backend to emit CIL for a simple identity function in about ~1.5 days, starting with little to no knowledge about how <code>rustc</code> works on the inside. Once you get the hang of it, building more complicated features does not take all that much time. It is, not, however, all rainbows and sunshine.</p>

<h1 id='undocumented_territory'>Undocumented territory</h1>

<p>Rust's std-lib and popular crates have spoiled us. Detailed explanations with examples, most of the time simple enough that a particularly smart child could probably figure it out. It is obvious that the compiler internals will not be documented nearly as well. It is constantly in motion (thank goodness!), so any sufficiently detailed explanation would quickly go out of date. This is a task of gargantuan proportions, one which requires so much knowledge, that only someone working on the compiler could describe some more obscure parts. And, I, for one, am glad that compiler people are focusing more on the compiler, not on writing its documentation.</p>

<p>It is still a potential hurdle for anyone interested in working on the compiler. It definitely steepens the learning curve, potentially reducing the number of people that can work on <code>rustc</code>. But! Fear not! There are definitely some moves to make the documentation better. Signs of active work can be seen, like <code>**Needs clarification**</code> notes under some explanations. One particularly funny example I had spotted was an unfinished sentence, with an issue regarding finishing it, linked just below. It may seem ridiculous at first, but there was a good reason for this. Ending it simply depended on some decisions related to the language that were not yet finalized. This once again highlights how hard writing a good documentation for <code>rustc</code>'s internals is: By saying 'X is always true' you are kind of committing to something.</p>

<p>What, in my case, more than made up for the shortcomings of the documentation, is how helpful a lot of the people working on the compiler are. I am a pretty shy person who always overthinks everything, so I was pretty reluctant to ask anything. Thankfully, it turns I stressed over nothing once again, and it was even better than what I hoped for. My questions were answered quickly, with some good advice for the future. It would still be great if all functions were documented (then there would rarely be a need to ask anyone anything), but it all worked out in the end, so I can't complain.</p>

<h1 id='steady_progress'>Steady progress</h1>

<p>After some initial troubles, I had managed to push on and got the project to a state in which some simple demo libraries could be compiled. A lot of stuff was relatively easy to handle, so over a couple of weeks I had added support for all kinds of stuff. I was regularly checking the disassembled C# code, created from CIL I emitted, to ensure everything looked OK. After about 2 weeks, I had support for all the binary operations (add, bit-shift, e.t.c), some unary ops (e.g. bitwise not) and operations without arguments (e.g. sizeof). The codegen was also able to handle a lot of building blocks related to control flow, like <code>if/else</code> statements, simple match statements, and while loops. For loops are kind of special, since they require support for iterators and generics. Additionally, they are likely to require heavy optimization to work at comparable speed. I had also added support for calls, and a lot of types, such as references, structs, tuples, arrays and slices.</p>

<h1 id='arrays_are_harder_than_they_look'>Arrays are harder than they look</h1>

<p>It has latter turned out, that the current implementation of arrays is highly flawed, and JIT sometimes seems to just decide to optimize reads/ writes to and from arrays to NOPs. Why exactly? I can't know for certain, but I have an idea that could potentially fix this issue. The <code>.volatile</code> prefix to a CIL instruction disables certain optimizations, so it could help. I won't implement it right now, since this is not the only issue with arrays, which need to be redesigned anyway.</p>

<p>What is the other issue? I based my implementation upon the way C# handles fixed-size arrays. They essentially work by creating a hidden, nested struct type with a <code>.size</code> in definition specifying its size in bytes. Some keen-eyed people may have already seen the problem:</p>

<p>Since the size of a fixed-size array is declared in bytes, there is no way to have support for both 32 bit and 64 bit machines at the same time. Some types, such as pointers, have their size depend on how big the address space is. So an array of 10 pointers is 40 bytes on a 32 bit machine and 80 bytes on a 64 bit one. So, there are 3 options: have separate executables for 32-bit and 64-bit architectures, crash on 64-bit ones, or use far more memory than needed on already memory-limited 32-bit systems. There is an alternative solution, but it is kinda hacky and needs some more consideration. Its biggest drawback is that it would create many unnecessary types.</p>

<p>Even with those kinds of issues, is still pressed on, at a pretty steady pace, successfully compiling more, and more complicated snippets of rust code.</p>

<h1 id='running_the_code_for_the_first_time'>Running the code for the first time</h1>

<p>Fairly confident in the project, I had decided to create a small <code>Hello World</code> example. Since using C# APIs from rust is still far off, I had hard-coded some functions from the C standard library. This is something I will need to do anyway, since Rusts stdlib depends on <code>libc</code>. This is the easiest way to bring Rust's stdlib to .NET, since it does not require any rewrites. But I digress. Using the <code>putc</code> function, I can print a simple message to the console. I run my backend, creating a CIL file containing the <code>hello world</code> program. With anticipation, I type <code>ilasm hello</code>. I start to smile as the words <code>Operation completed successfully</code> appear within the terminal. I feel a rush of adrenaline and endorphins. Sure, I had used my backend to compile more advanced libraries before, but all I knew is that they were valid CIL, and decompiled C# suggested they would work. This small <code>hello world</code> program would be the first snippet of Rust code to run within a .NET runtime. I type <code>mono hello.exe</code>, expecting the words <code>Hello CLR from Rust!</code> to appear on my screen. Instead, I am greeted with this little message:</p>

<pre><code>Unhandled Exception:
System.InvalidProgramException: Invalid IL code in &lt;Module&gt;:main (intptr,byte**): IL_0000: ldc.i4.s  72</code></pre>

<p>Oh... that is not a good sign.</p>

<h1 id='ilasm_is_a_filthy_liar'>ILASM is a filthy liar</h1>

<p>You would assume that if some CIL code is blatantly wrong, <code>ilasm</code> would be unable to assemble it. This is sadly the case only with some mistakes. For some, it will not give you any warnings. You know what is worse? There is a subset of malformed CIL that the particular decompiler I was using(I can't say for all of them, I used only one) would turn into <strong>FULLY VALID C#</strong>, hiding the issue.  You know what is even worse? For some issues, both the runtime I was using (mono) and CoreCLR gave me not all that much info about what was wrong. CoreCLR's message was too generic, and while mono at least told me which method caused the issue, it was wrong about what was the problem exactly.</p>

<p>The part of the message about invalid IL code, instruction position and the instruction itself could lead you to believe that the instruction in question <code>ldc.i4.s</code> was the issue. So I tried removing it. Issue persisted. So I removed more. Nothing. Even more. More. MORE. Until all that was left was a single <code>ret</code> opcode. What? How is that possible? There is almost nowhere the issue can be? The only part left, besides the function signature and name, is...</p>

<h2 id='.locals'>.locals</h2>

<p>Any function in CIL has to declare all of its local variables. A valid declaration of locals looks something like this:</p>

<pre><code>.local(
   [0] int32,
   [1] float32,
   [2] int8,
   [3] int16*,
   [4] void*
)</code></pre>

<p>And one with the particular issue I was facing looks like this:</p>

<pre><code>.local(
   [0] int32,
   [1] float32,
   [2] int8,
   [3] int16*,
   [4] void
)</code></pre>

<p>You can't have a <code>void</code> type in locals. But why would you even have a void local in the first place? Rust likes to have locals with type void. And a LOT of them at that. Huh?</p>

<p>The reason <code>void</code> locals are so prevalent in <code>MIR</code> is mostly related to function calls (other sources of void locals exist too). The way MIR is designed, each function is assumed to return something. And this is a great assumption, that simplifies a lot of stuff. Both functions returning void and ones returning something are treated exactly the same. Code can just handle <code>functions</code>, not <code>void functions</code> and <code>every other function</code>. Additionally,  this is very similar to how LLVM deals with void functions, so converting MIR to LLVM is easier too.</p>

<p>Why didn't I remove those void locals right away, and instead choose to emit CIL with them? Would they not be useless at best, make the compiled assembly larger, and could potentially confuse the JIT? Well, at this stage of the project, I don't actually want to emit optimal code. I want to emit code that is as similar to the original MIR as possible. That just makes debugging easier.</p>

<p>Wasn't the problem obvious right away? I mean, both C#/F# don't allow void locals, so why on earth would they be supported? In hindsight, it seems foolish to assume they would work. I thought that if both the ilasm and a decompiler had no problem with void locals, this would work out just fine. I had quickly written a piece of code to remove any instructions interacting with void locals, and then changed their type. I did not want to outright remove them, at least not for now, since that would make CILs locals not map 1 to 1 to MIR locals. This would make analyzing generated CIL harder, and I still need to do that very often. After this quick and dirty fix, I had reassembled the code, and run it. I sigh with relief, as I see the words:</p>

<p><code>Hello CLR from Rust</code></p>

<p>And this is where this story ends, at least for now.</p>

<h1 id='what_now?'>What now?</h1>

<p>Now that I know that compiling Rust for the .NET runtime is very much possible, I will need to clean the project up. It is very, <strong>very</strong> buggy and unstable. There are features that sometimes work, and sometimes do not. If I want to go any further, I need to rewrite some parts of the codegen. Currently, a lot of stuff is written with the assumption that ilasm will be used to assemble the final executable, which makes changing the CIL generator for a better one very hard. I also do things that are OK right now, but become a nightmare, the second I add support for generics. The way I assemble the final executable is also not all that great, since it is not really the way a <code>rustc</code> backend is supposed to create excutables. Overall, what happens now will be just a bit of boring, but necessary work.</p>

<p>Sadly I probably won't be able to work at anything similar to pace I worked on during those 2 weeks. As September comes closer by, so does the start of the school year, and the exams at the end of my high school. It will probably be wise to dial programming down, at least a little bit.</p>

<p>Still, if you want to, you can <a href='https://github.com/FractalFir/rustc_codegen_clr'>check out the project in its current state.</a> Just beware of the issues, and that this is a proof-of-concept strung together with gum and tape.</p>

<p>I hope you enjoyed this little article!</p>
</div></div></body></html>