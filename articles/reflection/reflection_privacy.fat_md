<metadata>
title = "Rust, reflection and access rules"
id = "refl_priv"
category = "hidden"
date = "28 Dec 2024"
</metadata>
<markdown>


Reflection is something a lot of people wish the Rust language had. It is not hard to stumble across somebody with an interesting use case for it.

People want to use it for serialization, [GCs](https://maplant.com/2024-12-13-Scheme-to-the-Spec-Part-I:-Concurrent-Cycle-Collection.html), better interop, and even auto-differentiation. 

If you can think of a task, there is somebody out there wishing they could implement it using reflection.

Sadly, it does not look like it is coming any time soon.

Still, silly things like “this feature does not exist yet” can’t stop us from talking about how it could or even must work.

Reflection interacts with the safety features of Rust in a somewhat counter-intuitive way. Those interactions force *any* reflection API to obey certain rules.

Those restrictions may seem obvious to people *designing* a reflection API, or to Rust experts, but they seem to be rarely mentioned.

This article will try to explain those rules in simple, digestible terms. I will not only show *how* things have to work, but I will also explain *why* those requirements exist.

Additionally, I will explore the knock-on effects of such restrictions - mainly revolving around accessing fields. You may be surprised just how much those affect the shape of potential reflection APIs.

# Field access rules

In a lot of languages, reflection is able to access all the fields of an object, no matter if they are private or not. Reflection just seems to be a bit special, and able to bend the rules here and there.

There are, of course, some restrictions to this, but, in general, the rules around reflection tend to be less strict.

Coming from a high-level language with reflection, it seems reasonable to assume that this is a natural part of reflection.
You can set the value of a private field in C#:
```csharp
class Test {
  private float _secret;
}
void SetSecret(Test test, float val) {
  typeof (Test).GetField("_secret", BindingFlags.NonPublic | BindingFlags.Instance).SetValue(test, val);
}
```
In java:
```java
class Test {
	private float _secret;
}
class Spy {
	void SetSecret(Test test, float val) {
    	Field field = getField(test.getClass(), “_secret”);
    	field.setAccessible(true);
    	field.set(test, val);
	}
}

```
This is even easier in other languages, like python or lua; There, the notion of privacy is more of a courtesy than a rule.

```python
setattr(test, “__secret”,val);
```
```lua
test[“secret”] = val;
```

Doing things this way is often seen as an anti-pattern, since it breaks encapsulation. Nevertheless, it is useful in certain scenarios; for example, when serializing and deserializing data. After all, requiring all serializable / deserializable fields to be public would probably bring more trouble than it is worth.

You may ask: So what? Yes, in a lot of modern languages, reflection is able to access private fields, but what has it got to do with Rust?

Well, things can’t work this way in Rust, no matter what reflection API ends up being implemented. Let me show you why.

# Proof by contradiction

Since reflection is not something trivial to understand, you might expect the example showing problems with it to be complex too.

Thankfully, it can be demonstrated with some widely used Rust types, like `Box<i32>` - which means you don't need too much knowledge to understand how things work.

Let us suppose we have some way of accessing all fields using reflection, and we use that hypothetical API to write a function like this:
```rust
/// Gets a mutable reference to the first field of a struct using reflection
fn get_first_field_mut<T,F>(t:&mut T)->&mut F{
	// Implemented using reflection
}
```
At a first glance, it does not seem all that scarry. It doesn’t do much, besides just getting a mutable reference to a (potentially) private field.

In other languages, accessing private fields is considered a necessary evil. Sure, if you get too... creative with it, your coworkers might want to make you past tense. Still, as long as you have a *very good reason* to use reflection like this, and use it sparingly, everything is going to be fine.

In Rust, this is something that simply can’t be done - allowing reflection to access private fields is *fundamentally unsound*.

How? Let me show you.

Using this seemingly innocent function, we write something like this:

```rust
// A `Box<i32>` points to a heap-allocated integer
let boxed = Box::new(1_i32);
// Walk trough internal types of `Box`, to find its internal pointer
let unique = get_first_field_mut(&mut boxed);
let non_null = get_first_field_mut(unique);
let raw_ptr:&mut *const i32 = get_first_field_mut(non_null);
// After getting the internal pointer of `Box<i32>`, we replace it with an invalid one.
*raw_ptr = 0xDEAD_BEEF_usize as *const i32;
// The box now points to an invalid memory location, so trying to read its value is UB
// and may cause our program to crash
let val:i32 = *boxed;
```

This may be a bit hard to follow, so stick with me.

As you may know, the `Box` type allows us to store data on the heap. Inside a Box, we can find a pointer to this data.

A Rust Box is made up from several layers of types(`*T`, `NonNull<T>`, `Unique<T>`, `Box<T>`), each telling us more about the pointer.

Here, we use reflection to go through all of those types, and replace that pointer (eg. `0x7dff_3340`) with a garbage value (`0xDEAD_BEEF`).

Now, the box "thinks" its value is at some unrelated address. When we try to get that value back, we will cause Undefined Behavior(UB).

Depending on what exactly is present at that memory location, our program might crash, or read some unrelated piece of data.

This effectively breaks memory safety, so it must be, by definition, impossible in safe Rust.


At this point, I think you can also see exactly *why* a safe reflection API can't allow this to happen.
So, reflection in Rust **must respect** the field access rules.

In other languages, breaking those rules is going to make your program hard to read.
In Rust, those rules are strictly necessary for enforcing safety. Breaking them kind of breaks the whole language, which is less than ideal.

So, reflection in Rust must either respect access rules (aka “field privacy”) or be *unsafe*.

Immediately, you may have a few questions.
1. This problem seems to be caused by us creating a mutable reference to a private field. Do immutable references have similar problems?
2. This issue is caused by a pointer. Would forbidding accessing pointers in reflection help?
3. Is this that big of an issue? Nobody is going to write code like that anyway?
4. Why does reflection even need to access private fields? What would be the limitations of reflection without access to private fields?

All of them are important, so let's start with the first few.

At first, it may seem like we need mutable access to cause any trouble. After all, if we can’t change the underlying data, we can’t really cause any harm, can we? So, you might think that kind of restriction on reflection should be enough.

*Well*, we can still do quite a bit of harm with an “immutable” reference. While *most* Rust types can’t be changed without obtaining a mutable reference, some of them can. So, allowing any sort of unintended access to private fields is a recipe for disaster.

Consider the reference count of an `Arc`. The counter is an `AtomicUSize` - a type which can be changed, without the need for a mutable reference. If we could, for example, set its counter to `1`, when it ought to be higher, we could cause an use-after-free bug.



```rust
let a = Arc::new(7);
let b = a.clone();
let count = get_arc_count_via_reflection(&a);
count.store(1, Ordering::Relaxed);
// Frees the underlying arc - b is now dangling!
drop(a);
```
This example also shows the second issue: it is not just pointers we need to worry about.

Changing pretty much any private data can cause issues. We could, for example, corrupt an integer, representing a handle to an object created by a C library. This could, in turn, lead to soundness issues.
```rust
// A OpenGL Vertex Buffer Object is just a uint on the C side
let mut vbo = /* get VBO from Open-Gl */;
let handle = get_first_field_mut(&mut vbo);
handle = 0xDEAD_BEEF_u32; // We change the OpenGL handle - bad things could happen now
// Oops! We used a corrupted handle...
vbo.bind();
```
This hopefully shows that reflection with access to private fields could lead to issues. You might be tempted to ask: are those issues realistic?

The simplest, but a bit boring answer to this question is that this does not matter. Even if something is “unlikely” to cause UB, it still must be unsafe in Rust. So, if accessing private fields via reflection could cause UB, then it is by definition, unsafe.

Let me ask you a simple question: what should happen when somebody uses reflection to try to serialize (eg. save to disk) an OpenGL buffer? If we don’t restrict reflection, then the serialization framework may just save the handle as a plain integer.

Then, when we deserialize it, it is going to be invalid, and can cause serious trouble.

Rust is a language focused on security, and requiring people to know what can and can’t be safely serialized just does not mesh well with that.

## Unsafe fields

By this point, you probably get the general gist of things. Reflection in Rust simply can't safely access private fields. I think a lot of people also think that allowing reflection to access private fields is a bad idea in general. So, not much is lost here.

Still, saying that something is “not possible and also a bad idea” feels a bit anticlimactic.
Surely, there must be some way to eat our cake and have it too. Enabling reflection to access private fields is arguably useful: a lot of languages use reflection to implement serialization.

Ideally, we would not want to force all serializable types to only have public fields. That is probably going to cause a lot more trouble than it is worth.

You might think: Ok, so we can’t allow reflection to access all private fields, since some of them may be unsafe to access. We still may want it to access some fields that we would like to stay private otherwise.

Maybe we could implement a visibility marker that allows for reflective access to such fields?  Something like:
```rust
struct MostlyPrivate{
 	/// Normally private, but accessible via reflection
	pub(reflect) id:u32,
}

```
This, at least to me, looks reasonable. We explicitly opt in to reflection, clearly marking which fields it can and can't change. We still get some of the benefits of making things private. Such fields are not accessible from "normal"(human-written) code, so it is unlikely somebody will access them by accident.

Reflection is not easy, and if somebody uses it to access such a field, we should just let them do so. Clearly, they have a rough idea about what they are getting themselves into.

This solution is not perfect, but it forces us to acknowledge the potential issues and work around them.

Still, one might argue that the opt-in nature of this feature would lead to a lot of people forgetting about it. It would require some change to the thinking of crate authors, who would have to explicitly add reflection support for their types.

Alternatively, we could consider poaching a few ideas from the unsafe fields feature.
```rust
struct FloatAndEven{
	/// Safety: must be even!
	// Invisible to reflection, since it is unsafe
	unsafe even:i32,
	// Accessible via reflection, since it is not unsafe
	float:f32,
}
```

If we assume any field which is not unsafe can be safely reflected on, then maybe things will work out? It is hard to say if this would be enough, and I am not convinced mixing reflection access and field safety is a good idea. Still, I feel like this solution is something that ought to be mentioned for the sake of completeness.
# Domino effect: how those restrictions affect reflection

At this point, you probably see why reflection in Rust must respect field access rules. I think most people would agree that allowing reflection to break them is a bad idea in general. So, I don’t think anybody is going to be too mad at this “restriction”.

All proposals I have seen so far do things this way anyway, so this is not a big discovery. Still, I like to explain why something is a certain way before I explain the consequences of that behaviour. Now that this is out of the way, we can start talking about something far more interesting: the knock-on effects.

Think for a second about what should happen when something goes wrong during reflection. You can’t safely deserialize a type like this:
```rust
struct NotOk{
	// Private field reflection can’t access
	private:u32,
}
```
Reflection can’t access some of its fields, so it can’t be used for deserialization. This leads me to ask a simple question: what should happen then? The obvious answer is that this should result in a compiler error, but… it is not as simple as that.

## Why reflection needs custom bounds

To give an example, let us say that we create a serialization function like this:
```rust
pub fn serialize<T: /* What should go there???*/>(t:&T, out: &mut impl Write)->SerializationResult{
	/* Implemented using reflection*/
}
```

How should we express the bounds of reflection-based serialization? To serialize a type using reflection, we need it to fulfill a set of non-trivial criteria.

All of its fields need to be accessible via reflection
Each and every single field type must also be serializable, that is either:
A primitive type, e.g. `a:i32`
A type with an explicit serialization implementation, eg. `b:Box<i32>`
A type which also fulfils our criteria `c:SomeOtherSerializableType`
Thus, a simple question arises: how are we supposed to express those complex bounds?

One idea might be to… just not add any such bounds at all? If our reflection-based serialization framework errors out with a descriptive message, then isn’t this bound kind of redundant?
```
error[E1234]: reflection error
  --> my_type.rs:32:64
   |
32 | pub(crate) not_serializable:*mut i32,
   | -^^^^- This field cannot be accessed via reflection
   |  |
   |  type MyType can’t be serialized because of this field
   |
   = note: Error during compile-time reflection
note: this error was caused by a reflection-based function called here
  --> test_serialization.rs:128:256
   |
128| serialize(&my_type, &mut out_file).unwrap();
   |  	^^^^

```
Sadly, no. Consider a much more complex example. Who is to say that the problematic function is called directly? The error could, for example, originate **deep** within a networking framework, which ensures a piece of data stays in sync across the network.

Should the compiler emmit a backtrace in such a case?
```
reflection_serializer::serialize<MyType>
network_framework::SharedData<MyType>::send
network_framework::SharedData<MyType>::sync
network_framework::SharedData<MyType>::new
my_crate::my_code
```
This feels a bit... subpar. The idea of compiler errors containg backtraces like this seems very cumbersome.  

Most of this info is not all that relevant to the underlying problem.

If we had some support for expressing reflection bounds, the error would be much cleaner. We simply did not fulfill the bounds of the top-level function.
```
error[E1234]: reflection bound not satisfied
  --> my_type.rs:32:64
   |
32 | let score = SharedData::new(MyType::default());
   | 						-^^^^- This call requires `MyType` to fulfill the reflection bound 
   |  						|
   |  						type MyType does not fullfill the `reflection_serializer::is_serializable` bound
   |

```
Additionally, supporting those "reflection bounds" would prevent peopele from accidentaly rellying on a function that has some specific reflection requirements.

For example, the person writing our hypothetical `network_framework` would have to conciusly acknowledge that their code only works with serializable types.


Also, who is to say that the problem is directly with the type we have created? Maybe we are using types from other crates, which in turn use other crates, and the problem is with the type all the way down?

Now, our reflection error backtrace will grow even larger and even more confusing. We probably don't want to disply 10 layers of types just to show the problem at hand.

Since reflection can “fail” (eg. not have access to all the data it needs), we need to handle that in a sane way. 

Beining explict about our bound seems like the most reasonable and user-friendly solution. If we could do something like this:
```rust
fn serialize<T:SerializableViaReflection>(t:&T, out:&mut impl Write) ->SerializationResult{ /**/}
```
Then, all the crates using such a reflection-based serialization framework could also transparently express this requirement.
```
// In network_framework
fn send<T:reflection_serializer::SerializableViaReflection>(t:T){ /**/}
```

At this point, you probably see why we need *some* way to create custom bounds for reflection purposes. 

We need those "reflection bounds" to be very flexible, since peopele want to use reflection for a variaty of purposes. We don't want to limit its use cases.

Our bounds also need to be *very*, *very* precise. We don't want to have any types which fullfill the bounds, but then cause refelction to error-out. 

That is a lot of requirements... What are our options?

## How can we express such complex bounds?
Your gut feeling may be adding some simple-ish mechanism to check if a generic condition holds true for all fields.

However, this may not be nearly as simple as one might imagine.

A lot of people want to do a lot of different things with reflection. In each scenario, the requirements are a tiny bit different.

For example: let us say we have a function that sends some data between different devices. For optimization purposes, it only supports types which can be trivially copied between those devices: that is, they are `Copy` and their layout does not depend on the device in question: they are bitwise identical after they are sent. This is not something any combo of traits can currently express.

Furthermore, we may want to use reflection for interop. To give an example, my crate, `wrapped_mono`, currently uses unsafe marker traits to check if a type can be shared between C# code running within the .NET runtime and Rust. On the .NET side, I have access to APIs which can check the exact layout of a type. If I could do the same on the Rust side, I could ensure all the safety requirements in the crate code. All of my traits would then become safe, since I could prove that the types on both ends meet.

This kind of requirement can’t be expressed trivially. Furthermore, one might consider using reflection for automatically registering Rust types in an embedded scripting environment. Once again, the requirements here are not trivial expressible using the current trait system, which limits the usefulness of any potential reflection API in that use case.

If we want to implement something like that using reflection, we need some way of turning those vague requirements into generic bounds.  

One idea here might be to also use reflection to express those requirements.

We could try something like this:
```rust
const fn is_serializable<T>()->bool{
	/* Do our complex checks using reflection*/
}
// Only valid if is_serializable<T>() returns true
fn serialize<T>(t:&T, out:impl Write) where True<{is_serializable::<T>()}>
```

In this scenario, we express the bound required for reflection… using reflection. This approach has the benefit of being very flexible. We are not limited by what kind of checks we could possibly perform, and we could ensure some very complex safety invariants at compile time, which is neat.


However, once again, this approach is not without its own drawbacks. Writing those bounds is not trivial, which would make using reflection in Rust... not easy by any stretch of imagination. Still, reflection is not easy in general, so one might argue that this does not matter as much here.

The bigger drawback is, in my opinion, the problem of self-referential types. Consider this one:
```rust
struct IsThisThingSerializable{
	normal_field:u32,
	recursive:Option<Box<Self>>,
}
```
Checking if this thing fulfils our complex reflection requirements is not trivial. This type can be serialized if all of its fields(including `recursive`) can be serialized.
To determine if that field can be serialized, we need to check if... the original type in quiestion can be serialized.

A naive approach, written using recursion, would quickly get stuck in a loop.


Making this work reliably is not trivial. There could exist some kind of crate that makes this process easier, but I still feel like the complexity of reflection rears its ugly head here too.

Overall, it seems like this is, once again, something that makes implementing reflection in Rust all that more tricky.

# Uncharted seas

I feel a bit weird leaving this article without presenting a neat solution to the problems I presented. However, I think this is the most important thing to take away here: we kind of are in uncharted waters. Reflection has been implemented in other languages before, but I don’t believe it ever was implemented in a language as unique as Rust.

Rust’s focus on enforcing safety via its type system also forces reflection to be more strict, and perhaps a bit more cumbersome.

Truth be told, this article is kind of a result of my own work on reflection. I have tried quite a few different approaches to slay this beast of a feature, with... mixed results.

Time and time again, I feel like I kind of smashed into the same potential issues, despite using vastly different approaches.

Sometimes, I feel like attempting to add reflection to Rust is kind of like trying to cover a table with too small of a tablecloth: you always end up sacrificing something. Some of my ideas were very powerful, decently user-friendly, but ultimately unsafe.
Others were safe, but required writing more boilerplate, and did not cover all the use cases I, and countless other rustecians had in mind.

As the year 2024 is coming to an end, I came to a realization: I don't need to solve all of those problems.

I am a bit of a perfectionist, and got stuck in a pretty simple trap: I did not want to write anything about reflection till I figured everything out. However, letting my 10 draft articles bit-rot in the cloud is not doing anybody any good.


Rust is a language that lives or dies by its community: The best thing I can do is get more eyes on the problem.



</markdown>


